from .models import Login
from sqlmodel.ext.asyncio.session import AsyncSession
from sqlmodel import select
from .schema import Auth
from .utils import generate_hash_password,verify_password
from fastapi import HTTPException
import logging
from .models import Login

class LoginService:
    async def get_user_by_email(self,email:str,session:AsyncSession):
        statement = select(Login).where(Login.email==email)
        result = await session.execute(statement)
        return result.scalars().first()
    
    async def user_exist(self,email:str,session:AsyncSession):
        user = await self.get_user_by_email(email,session)
        if user is None:
            return False
        else:
            return True
        
    async def createAccount(self,userData:Auth,session:AsyncSession):
        user_data_dict = userData.model_dump() # converting into dict using model_dump()
        user = Login(
            **user_data_dict
        )
        user.password = generate_hash_password(user_data_dict['password'])
        
        try:
            session.add(user)
            await session.commit()
            await session.refresh(user)
            '''
            Why session.refresh() is Needed
                SQLAlchemy's behavior: After calling session.commit(), the object might not be fully updated in memory.
                For example, fields like id (which are usually auto-generated by the database) are not immediately
                reflected in the Python object.

                session.refresh(): This ensures the SQLModel instance is refreshed with the latest data from the database,
                which includes any fields that were generated or modified during the commit.
            '''
            return user.model_dump()
        except Exception as e:
            await session.rollback()
            logging.error(f"IntegrityError: {str(e)}")  # Log the error
            raise HTTPException(status_code=400, detail="Unique constraint violated")